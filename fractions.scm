(define infty 'nil)

(define (rat-to-cf r) 
  (let* ((ipart (floor r))
	 (fpart (- r ipart)))
    (if (= fpart 0) (list ipart)
	(append (list ipart) (rat-to-cf (/ fpart))))))
(define (dec-to-cf d)
  (let ((rep (rat-to-cf (rationalize (inexact->exact d) 0))))
    rep))
(define (cf-to-rat frep)
  (if (null? (cdr frep)) (/ (car frep))
      (+ (car frep) (/ (cf-to-rat (cdr frep))))))
(define (cf-to-dec z)
  (exact->inexact (cf-to-rat z)))

(define (gen-normal-cf-terms n k)
  (define (frac-iter i cf)
    (if (= i k)
	cf
	(frac-iter (+ i 1) (append  cf (list (n i)))) ))
  (frac-iter 0 '()))
(define (quadratic-surd i periodic-seq)
  (list-ref periodic-seq (remainder i (length periodic-seq))))
(define (cf-quadratic-surd x i)
  (if (= i 0) (caar x)
      (quadratic-surd (- i 1) (cadr x))))
;see http://perl.plover.com/classes/cftalk/TALK/slide027.html
;; (define (z-machine (a b c d x))
;;   (let ((a/c  (/ a c))
;; 	(b/d  (/ b d))
;; 	(p (car x))
;; 	(x' (cdr x)))
;;     (if (= (floor a/c) (floor b/d)) (floor a/c)
;; 	(z-machine b (+ a (* b p)) d (+ c (* b p)) x'))))

;; Tests:
(define pi 3.14159265358979)
(define phi (/ (+ 1 (sqrt 5)) 2))
(define (cf-phi i)  1)
(define (cf-sqrt-3 i)
  (cf-quadratic-surd '((1) (1 2)) i))

(display (= (cf-to-dec (dec-to-cf pi)) pi) )
(display "\n")
(display `(,(cf-to-dec (gen-normal-cf-terms cf-phi 1000))  ,phi))
;(display (= (cf-to-dec (gen-normal-cf-terms cf-phi 1000)) phi))
(display "\n")
(display `(,(sqrt 3) ,(cf-to-dec (gen-normal-cf-terms cf-sqrt-3 100))) )
(display "\n")

